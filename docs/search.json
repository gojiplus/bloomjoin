[{"path":"https://soodoku.github.io/bloomjoin/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 bloomjoin authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://soodoku.github.io/bloomjoin/articles/benchmarking-bloomjoin.html","id":"helper-functions","dir":"Articles","previous_headings":"","what":"Helper Functions","title":"Benchmarking Bloom Filter Joins","text":", define helper functions used benchmarking process. Note ’ll using bloom_join function internal perform_standard_join function bloomjoin package compare performance. Next, define function run single benchmark comparison across different join methods. function generates test data, verifies results bloom_join standard join equivalent, compares performance. available, also benchmarks data.table join. Running benchmark 1/6: x=1000, y=1000, overlap=0.010 Running benchmark 2/6: x=1000, y=1000, overlap=0.500 Running benchmark 3/6: x=5000, y=5000, overlap=0.010 Running benchmark 4/6: x=5000, y=5000, overlap=0.500 Running benchmark 5/6: x=1000, y=10000, overlap=0.010 Running benchmark 6/6: x=10000, y=1000, overlap=0.010","code":"We also define a function to generate synthetic test data with a controllable percentage of overlapping keys.   ``` r # Function to generate test data with controllable overlap generate_test_data <- function(n_x, n_y, overlap_pct = 0.5, key_cols = 1, value_cols = 3) {   n_overlap <- round(min(n_x, n_y) * overlap_pct)      # Create a pool of unique IDs first   set.seed(123)   total_ids_needed <- n_x + n_y - n_overlap   unique_ids <- paste0(\"ID\", sprintf(\"%09d\", sample(1:(total_ids_needed * 2), total_ids_needed)))      # Assign IDs to each table   x_ids <- unique_ids[1:n_x]   y_ids <- c(     # Overlapping IDs     sample(x_ids, n_overlap),     # Non-overlapping IDs     unique_ids[(n_x + 1):(n_x + n_y - n_overlap)]   )   # Shuffle the y_ids to randomize their order   y_ids <- sample(y_ids, n_y)      # Create data frames   df_x <- data.frame(key = x_ids, stringsAsFactors = FALSE)   df_y <- data.frame(key = y_ids, stringsAsFactors = FALSE)      # Add additional value columns   for (i in 1:value_cols) {     df_x[[paste0(\"x_val\", i)]] <- rnorm(n_x)     df_y[[paste0(\"y_val\", i)]] <- rnorm(n_y)   }      return(list(x = df_x, y = df_y)) } # Function to run a single benchmark comparison run_benchmark <- function(n_x, n_y, overlap_pct = 0.1, key_cols = 1, value_cols = 3,                            join_type = \"inner\", times = 2, seed = 123) {   # Set seed for reproducibility   set.seed(seed)      # Generate test data   data <- generate_test_data(n_x, n_y, overlap_pct, key_cols, value_cols)   df_x <- data$x   df_y <- data$y      by_cols <- if (key_cols == 1) \"key\" else paste0(\"key\", 1:key_cols)      # Get memory measurements for dplyr join   gc()   dplyr_mem_start <- gc(reset = TRUE)   dplyr_time <- system.time({     for(i in 1:times) {       dplyr_result <- perform_standard_join(df_x, df_y, by = by_cols, type = join_type)     }   })[\"elapsed\"] / times   dplyr_mem_used <- gc(reset = TRUE)   dplyr_mem <- sum(dplyr_mem_used[,2]) - sum(dplyr_mem_start[,2])      # Get memory measurements for bloom_join   gc()   bloom_mem_start <- gc(reset = TRUE)   bloom_time <- system.time({     for(i in 1:times) {       bloom_result <- bloom_join(df_x, df_y, by = by_cols, type = join_type)     }   })[\"elapsed\"] / times   bloom_mem_used <- gc(reset = TRUE)   bloom_mem <- sum(bloom_mem_used[,2]) - sum(bloom_mem_start[,2])      # Get final results for row counts   dplyr_result <- perform_standard_join(df_x, df_y, by = by_cols, type = join_type)   bloom_result <- bloom_join(df_x, df_y, by = by_cols, type = join_type)      # Estimate the number of rows after filtering based on overlap percentage   # Since we don't have bloom filter stats in our simplified implementation   # We'll use a more accurate estimate based on actual join result size   rows_after_filter <- round(nrow(bloom_result) * 1.2)  # Add a 20% margin    # Create result data frame with guaranteed values and ensure all are numeric   data.frame(     n_x = as.numeric(n_x),     n_y = as.numeric(n_y),     overlap = as.numeric(overlap_pct),     dplyr_time_ms = as.numeric(dplyr_time * 1000),     bloom_time_ms = as.numeric(bloom_time * 1000),     dplyr_mem_mb = as.numeric(dplyr_mem / (1024^2)),     bloom_mem_mb = as.numeric(bloom_mem / (1024^2)),     rows_before = as.numeric(n_x),     rows_after = as.numeric(rows_after_filter),     filter_efficiency = as.numeric(1 - (rows_after_filter / n_x)),     output_rows = as.numeric(nrow(bloom_result)),     speedup = as.numeric(dplyr_time / bloom_time),     mem_reduction = as.numeric(dplyr_mem / bloom_mem),     stringsAsFactors = FALSE   ) }  perform_standard_join <- function(x, y, by = NULL, type = \"inner\") {   # Check if dplyr is available   if (!requireNamespace(\"dplyr\", quietly = TRUE)) {     stop(\"The dplyr package is required for join operations\")   }    # Perform the join based on the specified type   if (type == \"inner\") {     return(dplyr::inner_join(x, y, by = by))   } else if (type == \"left\") {     return(dplyr::left_join(x, y, by = by))   } else if (type == \"right\") {     return(dplyr::right_join(x, y, by = by))   } else if (type == \"full\") {     return(dplyr::full_join(x, y, by = by))   } else if (type == \"semi\") {     return(dplyr::semi_join(x, y, by = by))   } else if (type == \"anti\") {     return(dplyr::anti_join(x, y, by = by))   } else {     stop(\"Unsupported join type\")   } } # Run a series of benchmarks with varying data sizes and low match rates run_benchmarks <- function() {   # Set global seed   set.seed(42)      # Include a variety of test cases to evaluate different scenarios   test_cases <- list(     # Format: n_x, n_y, overlap          # Small datasets      c(1000, 1000, 0.01),    # Small with very low overlap     c(1000, 1000, 0.5),     # Small with high overlap          # Medium datasets     c(5000, 5000, 0.01),    # Medium with very low overlap     c(5000, 5000, 0.5),     # Medium with high overlap          # Asymmetric sizes     c(1000, 10000, 0.01),   # Small-to-large with low overlap     c(10000, 1000, 0.01)    # Large-to-small with low overlap   )      results <- data.frame()      for (i in seq_along(test_cases)) {     case <- test_cases[[i]]     n_x <- case[1]     n_y <- case[2]     overlap <- case[3]          cat(sprintf(\"Running benchmark %d/%d: x=%d, y=%d, overlap=%.3f\\n\",                  i, length(test_cases), n_x, n_y, overlap))          tryCatch({       result <- run_benchmark(n_x, n_y, overlap, key_cols = 1,                               join_type = \"inner\", times = 1,                               seed = 123 + i)  # Different seed for each benchmark              if (is.data.frame(result) && nrow(result) > 0) {         results <- rbind(results, result)       } else {         cat(\"Warning: Benchmark produced no results\\n\")       }            }, error = function(e) {       cat(\"Error running benchmark:\", e$message, \"\\n\")     })   }      # Return a default result if no benchmarks succeeded   if (nrow(results) == 0) {     # Create a dummy result with sensible defaults     cat(\"No benchmarks completed successfully. Creating a dummy result.\\n\")     results <- data.frame(       n_x = 1000,       n_y = 1000,       overlap = 0.01,       dplyr_time_ms = 100,       bloom_time_ms = 90,       dplyr_mem_mb = 10,       bloom_mem_mb = 9,       rows_before = 1000,       rows_after = 10,       filter_efficiency = 0.99,       output_rows = 10,       speedup = 1.1,       mem_reduction = 1.1,       stringsAsFactors = FALSE     )   }      return(results) }  # Create a comprehensive comparison table create_comparison_table <- function(results) {   # Check that we have results   if (nrow(results) == 0) {     cat(\"No benchmark results available.\\n\")     return(invisible(NULL))   }      # Add protective conversion to ensure numeric values   results$overlap <- as.numeric(results$overlap)   results$filter_efficiency <- as.numeric(results$filter_efficiency)   results$output_rows <- as.numeric(results$output_rows)   results$n_x <- as.numeric(results$n_x)   results$n_y <- as.numeric(results$n_y)   results$bloom_time_ms <- as.numeric(results$bloom_time_ms)   results$dplyr_time_ms <- as.numeric(results$dplyr_time_ms)   results$speedup <- as.numeric(results$speedup)   results$bloom_mem_mb <- as.numeric(results$bloom_mem_mb)   results$dplyr_mem_mb <- as.numeric(results$dplyr_mem_mb)   results$mem_reduction <- as.numeric(results$mem_reduction)      # Create a more detailed table for all benchmark results   benchmark_table <- data.frame(     Dataset = paste0(format(results$n_x, big.mark = \",\"), \" × \",                      format(results$n_y, big.mark = \",\")),     Overlap = sprintf(\"%.2f%%\", results$overlap * 100),     Est_Filter_Efficiency = sprintf(\"%.1f%%\", results$filter_efficiency * 100),     Match_Rate = sprintf(\"%.2f%%\", results$output_rows / results$n_x * 100),     Bloom_Time_ms = sprintf(\"%.1f\", results$bloom_time_ms),     Dplyr_Time_ms = sprintf(\"%.1f\", results$dplyr_time_ms),     Speedup = sprintf(\"%.2f\", results$speedup),     Bloom_Mem_mb = sprintf(\"%.1f\", results$bloom_mem_mb),     Dplyr_Mem_mb = sprintf(\"%.1f\", results$dplyr_mem_mb),     Mem_Reduction = ifelse(results$mem_reduction >= 1,                           sprintf(\"%.0f%%\", (results$mem_reduction - 1) * 100),                           sprintf(\"-%.0f%%\", (1 - results$mem_reduction) * 100)),     stringsAsFactors = FALSE   )      # Display the table   cat(\"## Bloom Join Performance with Different Match Rates\\n\\n\")   print(knitr::kable(benchmark_table, caption = paste0(     \"Performance comparison with seed: 42 (\", nrow(results), \" benchmarks)\"   )))      # Calculate and display averages   if (nrow(results) > 1) {     cat(\"\\n\\n## Summary Statistics\\n\\n\")     summary_stats <- data.frame(       Metric = c(\"Average Est. Filter Efficiency\",                  \"Average Speedup\",                  \"Average Memory Reduction\"),       Value = c(         sprintf(\"%.1f%%\", mean(results$filter_efficiency, na.rm = TRUE) * 100),         sprintf(\"%.2f×\", mean(results$speedup, na.rm = TRUE)),         ifelse(mean(results$mem_reduction, na.rm = TRUE) >= 1,               sprintf(\"%.0f%%\", (mean(results$mem_reduction, na.rm = TRUE) - 1) * 100),               sprintf(\"-%.0f%%\", (1 - mean(results$mem_reduction, na.rm = TRUE)) * 100))       )     )     print(knitr::kable(summary_stats))   } }  # Run benchmarks and show results benchmark_results <- run_benchmarks() create_comparison_table(benchmark_results)"},{"path":"https://soodoku.github.io/bloomjoin/articles/benchmarking-bloomjoin.html","id":"bloom-join-performance-with-different-match-rates","dir":"Articles","previous_headings":"","what":"Bloom Join Performance with Different Match Rates","title":"Benchmarking Bloom Filter Joins","text":"Performance comparison seed: 42 (6 benchmarks)","code":""},{"path":[]},{"path":"https://soodoku.github.io/bloomjoin/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Gaurav Sood. Author, maintainer.","code":""},{"path":"https://soodoku.github.io/bloomjoin/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Gaurav Sood (2025). bloomjoin: Efficient Data Frame Joins Using Bloom Filters. R package version 0.1.2.","code":"@Manual{,   title = {bloomjoin: Efficient Data Frame Joins Using Bloom Filters},   author = {{Gaurav Sood}},   year = {2025},   note = {R package version 0.1.2}, }"},{"path":"https://soodoku.github.io/bloomjoin/index.html","id":"bloomjoin-bloom-filter-based-joins","dir":"","previous_headings":"","what":"Efficient Data Frame Joins Using Bloom Filters","title":"Efficient Data Frame Joins Using Bloom Filters","text":"R package implementing Bloom filter-based joins improved performance large datasets.","code":""},{"path":"https://soodoku.github.io/bloomjoin/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Efficient Data Frame Joins Using Bloom Filters","text":"BloomJoin provides alternative join implementation R uses hash-based approach inspired Bloom filters optimize performance joins data frames. Traditional joins R can inefficient dealing large datasets, especially one table significantly larger join key selectivity low.","code":""},{"path":"https://soodoku.github.io/bloomjoin/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Efficient Data Frame Joins Using Bloom Filters","text":"","code":"# Install from GitHub devtools::install_github(\"gojiplus/bloomjoin\")"},{"path":"https://soodoku.github.io/bloomjoin/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Efficient Data Frame Joins Using Bloom Filters","text":"","code":"library(bloomjoin)  # Basic usage result <- bloom_join(df1, df2, by = \"id\", type = \"inner\")  # With multiple join columns result <- bloom_join(df1, df2, by = c(\"id\", \"date\"), type = \"left\")  # With performance tuning parameters result <- bloom_join(df1, df2,                      by = \"id\",                      type = \"inner\",                     bloom_size = 1000000,                      false_positive_rate = 0.001,                     verbose = TRUE)"},{"path":"https://soodoku.github.io/bloomjoin/index.html","id":"how-it-works","dir":"","previous_headings":"","what":"How It Works","title":"Efficient Data Frame Joins Using Bloom Filters","text":"BloomJoin uses hash-based approach optimize joins: Create hash set keys lookup table (y) Filter primary table (x) include rows keys exist hash set Perform standard join filtered dataset pre-filtering step can significantly reduce size join operation many keys primary table don’t exist lookup table.","code":""},{"path":"https://soodoku.github.io/bloomjoin/index.html","id":"performance-benchmarks","dir":"","previous_headings":"","what":"Performance Benchmarks","title":"Efficient Data Frame Joins Using Bloom Filters","text":"See ","code":""},{"path":"https://soodoku.github.io/bloomjoin/index.html","id":"future-work","dir":"","previous_headings":"","what":"Future Work","title":"Efficient Data Frame Joins Using Bloom Filters","text":"Implement true Bloom filters potentially better memory efficiency Optimize composite keys join types Parallel processing hash creation filtering Automatic parameter tuning based input data characteristics","code":""},{"path":"https://soodoku.github.io/bloomjoin/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Efficient Data Frame Joins Using Bloom Filters","text":"MIT","code":""},{"path":"https://soodoku.github.io/bloomjoin/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Efficient Data Frame Joins Using Bloom Filters","text":"Contributions welcome! Please feel free submit Pull Request.","code":""},{"path":"https://soodoku.github.io/bloomjoin/reference/bloom_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Join two data frames using a Bloom filter implemented with Rcpp — bloom_join","title":"Join two data frames using a Bloom filter implemented with Rcpp — bloom_join","text":"function uses high-performance Rcpp implementation Bloom filters efficiently join large data frames. Bloom filter used pre-filter left data frame, reducing number comparisons needed actual join.","code":""},{"path":"https://soodoku.github.io/bloomjoin/reference/bloom_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Join two data frames using a Bloom filter implemented with Rcpp — bloom_join","text":"","code":"bloom_join(   x,   y,   by = NULL,   type = \"inner\",   bloom_size = NULL,   false_positive_rate = 0.01 )"},{"path":"https://soodoku.github.io/bloomjoin/reference/bloom_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Join two data frames using a Bloom filter implemented with Rcpp — bloom_join","text":"x data frame y data frame character vector variables join type Type join: \"inner\", \"left\", \"right\", \"full\", \"semi\", \"anti\" bloom_size Size Bloom filter. NULL, automatically calculated false_positive_rate False positive rate Bloom filter (default: 0.01)","code":""},{"path":"https://soodoku.github.io/bloomjoin/reference/bloom_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Join two data frames using a Bloom filter implemented with Rcpp — bloom_join","text":"joined data frame class \"bloomjoin\"","code":""},{"path":"https://soodoku.github.io/bloomjoin/reference/bloom_join.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Join two data frames using a Bloom filter implemented with Rcpp — bloom_join","text":"","code":"x <- data.frame(id = 1:100000, value_x = rnorm(100000)) y <- data.frame(id = 50001:60000, value_y = rnorm(10000)) result <- bloom_join(x, y, by = \"id\")"},{"path":"https://soodoku.github.io/bloomjoin/reference/bloomjoin.html","id":null,"dir":"Reference","previous_headings":"","what":"BloomJoin: Efficient data.frame joins using Bloom filters — bloomjoin","title":"BloomJoin: Efficient data.frame joins using Bloom filters — bloomjoin","text":"package provides optimized join operations large data frames using Bloom filters reduce memory usage improve performance. Bloom filter used pre-filter rows match final join operation, significantly reducing computational cost large datasets low overlap.","code":""},{"path":"https://soodoku.github.io/bloomjoin/reference/bloomjoin.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"BloomJoin: Efficient data.frame joins using Bloom filters — bloomjoin","text":"main function package bloom_join, implements various types joins (inner, left, right, full, semi, anti) using Bloom filters improve performance. particularly useful large datasets join operation otherwise memory-intensive slow.","code":""},{"path":"https://soodoku.github.io/bloomjoin/reference/bloomjoin.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"BloomJoin: Efficient data.frame joins using Bloom filters — bloomjoin","text":"Maintainer: Gaurav Sood gsood07@gmail.com","code":""},{"path":"https://soodoku.github.io/bloomjoin/reference/perform_standard_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform standard join operations — perform_standard_join","title":"Perform standard join operations — perform_standard_join","text":"Internal function perform standard join operations using dplyr","code":""},{"path":"https://soodoku.github.io/bloomjoin/reference/perform_standard_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform standard join operations — perform_standard_join","text":"","code":"perform_standard_join(x, y, by = NULL, type = \"inner\")"},{"path":"https://soodoku.github.io/bloomjoin/reference/perform_standard_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform standard join operations — perform_standard_join","text":"x data frame y data frame character vector variables join type Type join: \"inner\", \"left\", \"right\", \"full\", \"semi\", \"anti\"","code":""},{"path":"https://soodoku.github.io/bloomjoin/reference/perform_standard_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform standard join operations — perform_standard_join","text":"joined data frame","code":""}]
