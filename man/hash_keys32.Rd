% Generated by hand for hash_keys32 documentation
\name{hash_keys32}
\alias{hash_keys32}
\title{Hash composite join keys to 32-bit integers (stable & type-aware)}
\usage{hash_keys32(x, by, normalize_strings = TRUE)}
\arguments{
\item{x}{A data.frame or tibble containing the key columns.}

\item{by}{Character vector of column names forming the key, in order.}

\item{normalize_strings}{Logical; if \code{TRUE} (default) strings are normalized to UTF-8 before hashing.}
}
\value{
An integer vector of length \code{nrow(x)} containing deterministic 32-bit hashes. Values may be negative.
}
\description{
Produces a deterministic 32-bit integer per row from one or more key columns. The hash respects column types,
canonicalizes \code{-0} to \code{+0}, normalizes strings to UTF-8, and maps all NA/NaN variants to a single value.
Factors are hashed by their level strings so that factor/character equality works as expected.
}
\details{
Prior to hashing, POSIXlt columns are converted to POSIXct. When the optional \pkg{bit64} package is installed,
\code{integer64} columns are converted to their exact decimal string representations so they hash losslessly.
Without \pkg{bit64}, \code{integer64} inputs fall back to \code{as.character()} with the same equality semantics.
}
\examples{
if (interactive()) {
  df <- data.frame(
    id = c(1L, 2L, NA_integer_),
    ts = as.POSIXct("2020-01-01", tz = "UTC") + 0:2,
    value = c("a", "b", NA_character_),
    stringsAsFactors = FALSE
  )
  hash_keys32(df, by = c("id", "ts", "value"))
}
}
