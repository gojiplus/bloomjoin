% Generated by hand; keep in sync with R/params.R
\name{bloom_params}
\alias{bloom_params}
\alias{print.bloom_params}
\title{Choose Bloom filter parameters for a blocked layout}
\usage{
bloom_params(
  n,
  p = 1e-2,
  block_bits = 512L,
  min_k = 1L,
  max_k = 12L,
  round_to = block_bits
)

\method{print}{bloom_params}(x, ...)
}
\arguments{
\item{n}{Numeric scalar (> 0): expected number of distinct keys to insert. Fractional
values are allowed (estimates).}

\item{p}{Numeric scalar in (0, 1): target false positive rate.}

\item{block_bits}{Integer (default 512): block size in bits for a blocked Bloom filter.
512 corresponds to one 64-byte cache line.}

\item{min_k, max_k}{Integers giving the bounds for the number of hash functions (defaults
1 and 12).}

\item{round_to}{Integer or \code{NULL}. Round \code{m} up to a multiple of this many bits.
Defaults to \code{block_bits}; use \code{NULL} to disable rounding.}

\item{x}{A \code{bloom_params} object.}

\item{...}{Additional arguments passed to \code{print()}. Currently ignored.}
}
\value{
A list with class \code{"bloom_params"} containing the inputs and derived
parameters:
\itemize{
\item \code{n}: the input \code{n}.
\item \code{p_target}: the target false positive rate.
\item \code{block_bits}: the block size used when rounding.
\item \code{m_bits}: total number of bits after rounding.
\item \code{bytes}: total number of bytes.
\item \code{bits_per_key}: ratio of \code{m_bits} to \code{n}.
\item \code{k}: number of hash functions selected.
\item \code{fpr_est}: estimated false positive rate after rounding.
\item \code{blocks}: number of blocks (\code{m_bits / block_bits}).
}
}
\description{
Given an expected number of distinct keys \code{n} and target false positive rate \code{p},
compute total bits \code{m} (rounded up to a multiple of \code{block_bits}), number of hash
functions \code{k}, the achieved false positive rate after rounding, and related
quantities.
}
\details{
The helper uses the standard Bloom filter relationships:
\deqn{\mathrm{bits\_per\_key} = -\log(p) / (\log(2)^2)}
\deqn{k_\mathrm{opt} = \log(2) \cdot (m / n)}
\deqn{\mathrm{fpr}(m, n, k) = (1 - \exp(-k n / m))^k}
The \code{m} value is rounded to a multiple of \code{round_to} (defaulting to
\code{block_bits}) so that the resulting Bloom filter fits evenly into cache-line-sized
blocks.
}
\examples{
bp <- bloom_params(1e6, 1e-2)
bp
# Expect k ~ 7 and about 1.14 MiB of memory with 512-bit blocks.
}
